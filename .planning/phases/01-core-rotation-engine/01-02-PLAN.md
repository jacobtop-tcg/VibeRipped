---
phase: 01-core-rotation-engine
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/rotation.js
  - lib/cooldown.js
  - engine.js
  - test/engine.test.js
autonomous: true

must_haves:
  truths:
    - "System advances to the next exercise each trigger, wrapping from last to first"
    - "Triggering during cooldown returns cooldown info instead of an exercise"
    - "Exercise output is crisp command format with zero motivational language"
    - "Rotation position persists across process restarts"
    - "Pool change resets rotation index to 0"
    - "State file corruption recovers to defaults and engine still returns valid output"
  artifacts:
    - path: "lib/rotation.js"
      provides: "Sequential rotation through exercise pool with modulo wrap"
      exports: ["getNextExercise"]
    - path: "lib/cooldown.js"
      provides: "Wall-clock cooldown enforcement"
      exports: ["checkCooldown", "COOLDOWN_MS"]
    - path: "engine.js"
      provides: "Main entry point orchestrating rotation, cooldown, state, and output"
      exports: ["trigger"]
    - path: "test/engine.test.js"
      provides: "TDD test suite covering rotation, cooldown, corruption, and output format"
      min_lines: 80
  key_links:
    - from: "engine.js"
      to: "lib/rotation.js"
      via: "imports getNextExercise for rotation logic"
      pattern: "require.*rotation"
    - from: "engine.js"
      to: "lib/cooldown.js"
      via: "imports checkCooldown for rate limiting"
      pattern: "require.*cooldown"
    - from: "engine.js"
      to: "lib/state.js"
      via: "imports loadState/saveState for persistence"
      pattern: "require.*state"
    - from: "engine.js"
      to: "lib/pool.js"
      via: "imports DEFAULT_POOL for exercise data"
      pattern: "require.*pool"
    - from: "test/engine.test.js"
      to: "engine.js"
      via: "imports trigger function for integration testing"
      pattern: "require.*engine"
---

<objective>
Implement the rotation engine, cooldown enforcement, and main entry point using TDD, then verify the complete system against all Phase 1 requirements (ROTN-01, ROTN-03, ROTN-04, ROTN-05, STMG-01, STMG-02, STMG-03).

Purpose: This is the core logic that transforms triggers into exercise prompts. Rotation determines WHICH exercise; cooldown determines WHETHER to emit; engine.js orchestrates everything into a single trigger() function that downstream phases call.

Output: Fully tested rotation engine with cooldown enforcement. `node engine.js` triggers one exercise rotation and outputs structured JSON to stdout.
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-rotation-engine/01-RESEARCH.md
@.planning/phases/01-core-rotation-engine/01-CONTEXT.md
@.planning/phases/01-core-rotation-engine/01-01-SUMMARY.md
</context>

<feature>
  <name>Rotation Engine with Cooldown Enforcement</name>
  <files>lib/rotation.js, lib/cooldown.js, engine.js, test/engine.test.js</files>
  <behavior>
The engine exposes a `trigger()` function that:

1. Loads state from disk (via lib/state.js from Plan 01)
2. Checks cooldown: if less than 5 minutes since last trigger, returns cooldown response
3. If cooldown allows: gets next exercise from pool, advances index, updates lastTriggerTime, increments totalTriggered
4. Saves updated state atomically (via lib/state.js from Plan 01)
5. Outputs structured JSON to stdout

**Input/Output contracts:**

trigger() when cooldown allows:
```
Input: (none - reads state from disk)
Output: {
  type: "exercise",
  prompt: "Pushups x15",
  exercise: { name: "Pushups", reps: 15 },
  position: { current: 0, total: 10 },
  totalTriggered: 1
}
```

trigger() when in cooldown:
```
Input: (none - reads state from disk)
Output: {
  type: "cooldown",
  remainingMs: 180000,
  remainingHuman: "3m 0s"
}
```

**Rotation cases:**
- First trigger ever: returns exercise at index 0, advances to 1
- Nth trigger: returns exercise at index N-1 mod poolLength, advances to N mod poolLength
- After last exercise: wraps to index 0 (simple modulo, no shuffle)
- After pool change: resets to index 0 regardless of previous position

**Cooldown cases:**
- First trigger (lastTriggerTime is 0): always allows (0 is sentinel for "never triggered")
- Trigger after 5+ minutes: allows, updates lastTriggerTime
- Trigger during cooldown: returns remaining time, does NOT advance rotation

**Output format:**
- prompt field is crisp command: "{name} x{reps}" — e.g., "Pushups x15", "Wall sit x30"
- Zero motivational language, zero optionality, zero explanation
- For isometric exercises, reps means seconds (Phase 3 can format "30s" if desired; Phase 1 just uses "x30")

**Error cases:**
- Corrupt state file: recovers to defaults, triggers exercise from index 0
- Missing state file: initializes fresh, triggers exercise from index 0
- State save failure: still returns exercise output (log error to stderr)
  </behavior>
  <implementation>
**lib/rotation.js:**
- Export `getNextExercise(state, pool)` — returns `{ exercise: pool[state.currentIndex], previousIndex: state.currentIndex }`, then advances state.currentIndex via `(state.currentIndex + 1) % pool.length`. Mutates state in place.
- Pure function apart from state mutation. Does NOT handle cooldown or persistence.

**lib/cooldown.js:**
- Export `COOLDOWN_MS = 300000` (5 minutes, hardcoded for Phase 1)
- Export `checkCooldown(lastTriggerTime, cooldownMs)` — returns `{ allowed: boolean, remainingMs: number }`. If lastTriggerTime is 0 (never triggered), always returns allowed:true. Otherwise compares Date.now() - lastTriggerTime against cooldownMs.
- Export `formatRemaining(ms)` — converts milliseconds to human string like "3m 0s" or "45s".

**engine.js:**
- Export `trigger(pool, options)` — orchestrates the full trigger flow. Options: `{ statePath }` for testability (override default state path).
  1. Load pool (default: DEFAULT_POOL from lib/pool.js)
  2. Load state via loadState(pool)
  3. Check cooldown via checkCooldown(state.lastTriggerTime, COOLDOWN_MS)
  4. If cooldown not allowed: return `{ type: "cooldown", remainingMs, remainingHuman }`
  5. Get next exercise via getNextExercise(state, pool)
  6. Update state: lastTriggerTime = Date.now(), totalTriggered++
  7. Save state via saveState(state)
  8. Return `{ type: "exercise", prompt: formatPrompt(exercise), exercise, position: { current: previousIndex, total: pool.length }, totalTriggered: state.totalTriggered }`
- `formatPrompt(exercise)` — returns `${exercise.name} x${exercise.reps}` (crisp command, ROTN-04)
- CLI mode: if `require.main === module`, call trigger() and console.log(JSON.stringify(result))
- Set process.exitCode (not process.exit()) for clean async completion

**test/engine.test.js:**
Use Node.js built-in test runner (`node:test` + `node:assert`). No external test framework.

Test cases to write FIRST (RED phase):
1. "sequential rotation advances through pool" — trigger N times, verify exercises match pool order
2. "rotation wraps around at end of pool" — trigger pool.length + 1 times, verify wrap to index 0
3. "cooldown blocks trigger within interval" — trigger, immediately trigger again, verify cooldown response
4. "cooldown allows trigger after interval" — trigger, mock time forward, trigger again, verify exercise
5. "first trigger always allowed (sentinel 0)" — fresh state, trigger succeeds
6. "prompt format is crisp command" — verify output.prompt matches /^\w[\w\s]+ x\d+$/
7. "prompt has zero motivational language" — verify output.prompt does NOT contain "try", "great", "nice", "keep", "good", "let's", "!"
8. "corrupt state recovers and still returns exercise" — write garbage to state file, trigger, verify exercise returned
9. "pool change resets index" — trigger 3 times, change pool, trigger, verify starts at new pool[0]
10. "state persists across trigger calls" — trigger twice (separate calls), verify second returns pool[1] not pool[0]

For time-sensitive tests (cooldown), manipulate state.lastTriggerTime directly or use a mock time approach (pass Date.now override via options). Keep tests deterministic — no flaky timing.

Each test uses a temporary state directory (os.tmpdir() + unique suffix) to avoid polluting real state.
  </implementation>
</feature>

<verification>
1. `node --test test/engine.test.js` — all tests pass (10+ test cases)
2. `node engine.js` — outputs valid JSON with type "exercise" on first run
3. `node engine.js` immediately again — outputs JSON with type "cooldown" (within 5min window)
4. Delete ~/.config/viberipped/state.json, run `node engine.js` — outputs exercise (fresh state)
5. Write "GARBAGE" to state.json, run `node engine.js` — outputs exercise (corruption recovery)
6. Run `node engine.js` 10+ times (with cooldown disabled or state manipulation) — exercises cycle through entire pool and wrap
7. Output never contains motivational language — grep for "!", "try", "great", "nice", "good job"

Requirements coverage:
- ROTN-01: Sequential rotation verified by test cases 1, 2, 10
- ROTN-03: Cooldown enforcement verified by test cases 3, 4, 5
- ROTN-04: Crisp command format verified by test cases 6, 7
- ROTN-05: Persistence verified by test case 10
- STMG-01: Atomic writes verified by state.js (Plan 01) + integration in engine.js
- STMG-02: Corruption recovery verified by test cases 8 + verification step 5
- STMG-03: Pool hash detection verified by test case 9
</verification>

<success_criteria>
- All test cases pass with `node --test test/engine.test.js`
- `node engine.js` returns structured JSON with exercise prompt on first trigger
- Cooldown enforcement prevents re-trigger within 5 minutes
- Exercise prompts are crisp commands ("Pushups x15") with zero motivational language
- Rotation persists: restarting process continues from last position
- Corrupt/missing state recovers cleanly and engine still returns valid output
- All 7 Phase 1 requirements (ROTN-01, ROTN-03, ROTN-04, ROTN-05, STMG-01, STMG-02, STMG-03) are covered by tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-rotation-engine/01-02-SUMMARY.md`
</output>
