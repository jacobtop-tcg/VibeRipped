---
phase: 01-core-rotation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/pool.js
  - lib/state.js
autonomous: true

must_haves:
  truths:
    - "Exercise pool is a bounded array of bodyweight exercises with per-exercise rep counts"
    - "Pool hash changes when pool contents change and stays stable when they don't"
    - "State file persists across process restarts using atomic write-rename"
    - "Missing or corrupt state file resets to defaults without crashing"
    - "State directory is created automatically on first run"
  artifacts:
    - path: "package.json"
      provides: "Node.js project definition with write-file-atomic dependency"
      contains: "write-file-atomic"
    - path: "lib/pool.js"
      provides: "Default exercise pool and SHA256 pool hashing"
      exports: ["DEFAULT_POOL", "computePoolHash"]
    - path: "lib/state.js"
      provides: "Atomic state persistence with graceful corruption recovery"
      exports: ["loadState", "saveState", "getStatePath", "createDefaultState"]
  key_links:
    - from: "lib/state.js"
      to: "lib/pool.js"
      via: "imports computePoolHash for pool change detection"
      pattern: "require.*pool"
    - from: "lib/state.js"
      to: "write-file-atomic"
      via: "atomic file writes for crash safety"
      pattern: "require.*write-file-atomic"
---

<objective>
Scaffold the VibeRipped Node.js project and implement the two foundational modules: exercise pool definition with SHA256 hashing, and atomic state persistence with graceful corruption recovery.

Purpose: Establishes the data layer that the rotation engine (Plan 02) consumes. Pool defines WHAT exercises exist; state manages WHERE in the rotation we are and ensures that position survives crashes and restarts.

Output: Working package.json with dependencies installed, lib/pool.js exporting default pool and hash function, lib/state.js exporting load/save with atomic writes and corruption recovery.
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-rotation-engine/01-RESEARCH.md
@.planning/phases/01-core-rotation-engine/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Node.js project and install dependencies</name>
  <files>package.json</files>
  <action>
Create package.json at project root with:
- name: "viberipped"
- version: "0.1.0"
- description: "Deterministic micro-exercise rotation engine for Claude Code"
- main: "engine.js"
- type: "commonjs" (for require() compatibility with write-file-atomic)
- license: "MIT"
- scripts: { "test": "node --test" } (Node.js built-in test runner, no extra deps)

Install dependency:
- `npm install write-file-atomic` (atomic state persistence, crash-safe writes)

No other dependencies. Native Node.js modules cover everything else (crypto for hashing, fs for reads, path/os for XDG paths, readline for future stdin).

Do NOT install ajv — manual field validation is sufficient for 4 fields. Keep deps minimal.
  </action>
  <verify>
Run `node -e "require('write-file-atomic')"` — exits 0 with no error.
Run `cat package.json | node -e "const p=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log(p.name, p.dependencies['write-file-atomic'])"` — prints "viberipped" and a version string.
  </verify>
  <done>package.json exists with write-file-atomic as sole dependency. node_modules populated. No extraneous deps.</done>
</task>

<task type="auto">
  <name>Task 2: Create exercise pool module with SHA256 hashing</name>
  <files>lib/pool.js</files>
  <action>
Create lib/pool.js exporting two things:

1. `DEFAULT_POOL` — array of exercise objects, each with `{ name: string, reps: number }`. Bodyweight-only (pre-Phase 2 equipment config). Include 8-10 exercises that are:
   - Quick to perform (30-60 seconds max)
   - Low-sweat, low-recovery (preserve ability to code after)
   - No equipment required
   - Diverse muscle groups to avoid repetitive strain

Recommended pool (Claude's discretion on exact composition):
```
[
  { name: "Pushups", reps: 15 },
  { name: "Bodyweight squats", reps: 20 },
  { name: "Desk pushups", reps: 15 },
  { name: "Lunges", reps: 10 },
  { name: "Calf raises", reps: 25 },
  { name: "Tricep dips", reps: 12 },
  { name: "Wall sit", reps: 30 },
  { name: "High knees", reps: 30 },
  { name: "Glute bridges", reps: 15 },
  { name: "Plank", reps: 30 }
]
```

Note: "reps" for isometric holds (wall sit, plank) means seconds. Phase 3 can format display accordingly; Phase 1 just stores the number.

2. `computePoolHash(pool)` — takes a pool array, JSON-serializes it, computes SHA256 hex digest using native `crypto.createHash('sha256')`. Returns 64-char hex string.

Key details:
- Use `JSON.stringify(pool)` for deterministic serialization (array order matters, which is what we want — pool order IS the rotation order)
- Use `crypto.createHash('sha256').update(poolJson, 'utf8').digest('hex')`
- Export both as module.exports = { DEFAULT_POOL, computePoolHash }
  </action>
  <verify>
Run `node -e "const p = require('./lib/pool'); console.log(p.DEFAULT_POOL.length, typeof p.computePoolHash(p.DEFAULT_POOL))"` — prints a number >= 8 and "string".
Run `node -e "const p = require('./lib/pool'); const h = p.computePoolHash(p.DEFAULT_POOL); console.log(h.length, /^[a-f0-9]+$/.test(h))"` — prints "64 true".
Run `node -e "const p = require('./lib/pool'); console.log(p.computePoolHash(p.DEFAULT_POOL) === p.computePoolHash(p.DEFAULT_POOL))"` — prints "true" (deterministic).
  </verify>
  <done>lib/pool.js exports DEFAULT_POOL (8-10 bodyweight exercises with per-exercise reps) and computePoolHash (returns stable SHA256 hex string). Hash is deterministic for same input and changes for different input.</done>
</task>

<task type="auto">
  <name>Task 3: Create state persistence module with atomic writes and corruption recovery</name>
  <files>lib/state.js</files>
  <action>
Create lib/state.js exporting four functions:

1. `getStatePath()` — returns path to state.json:
   - Use `process.env.XDG_CONFIG_HOME || path.join(os.homedir(), '.config')` as base
   - Append `/viberipped/state.json`
   - Also export `getStateDir()` internally (for directory creation)

2. `createDefaultState(pool)` — returns fresh state object:
   ```
   {
     currentIndex: 0,
     lastTriggerTime: 0,
     poolHash: computePoolHash(pool),
     totalTriggered: 0
   }
   ```
   - Import computePoolHash from ./pool.js

3. `loadState(pool)` — loads state from disk with graceful recovery:
   - Try readFileSync(getStatePath(), 'utf8')
   - Try JSON.parse the content
   - Validate structure: check that currentIndex is integer >= 0, lastTriggerTime is integer >= 0, poolHash is string, totalTriggered is integer >= 0. If ANY field fails validation, reset to defaults.
   - Detect pool change: if state.poolHash !== computePoolHash(pool), reset currentIndex to 0, update poolHash
   - Bounds check: if state.currentIndex >= pool.length, reset to 0
   - On ENOENT (missing file): return createDefaultState(pool), log to stderr "No state file, initializing"
   - On SyntaxError (corrupt JSON): return createDefaultState(pool), log to stderr "State corrupted, resetting"
   - On validation failure: return createDefaultState(pool), log to stderr "State invalid, resetting"
   - NEVER throw — always return a valid state

4. `saveState(state)` — persists state atomically:
   - Create state directory with fs.mkdirSync(getStateDir(), { recursive: true, mode: 0o700 })
   - Use writeFileAtomic.sync(getStatePath(), JSON.stringify(state, null, 2), { mode: 0o600 })
   - Synchronous write is fine for Phase 1 (single trigger, not continuous stream)
   - If write fails, log error to stderr but do NOT throw (engine should still return output even if state save fails)

Key patterns:
- NEVER use fs.existsSync before read (TOCTOU vulnerability per research)
- All diagnostic output to stderr, never stdout (stdout is data channel)
- Import write-file-atomic at top level
  </action>
  <verify>
Run `node -e "const s = require('./lib/state'); const p = require('./lib/pool'); const state = s.loadState(p.DEFAULT_POOL); console.log(JSON.stringify(state))"` — prints valid JSON with currentIndex:0, lastTriggerTime:0, poolHash (64-char hex), totalTriggered:0.
Run `node -e "const s = require('./lib/state'); const p = require('./lib/pool'); const state = s.createDefaultState(p.DEFAULT_POOL); s.saveState(state); const loaded = s.loadState(p.DEFAULT_POOL); console.log(loaded.currentIndex === 0, loaded.poolHash === state.poolHash)"` — prints "true true".
Run `node -e "const fs = require('fs'); const s = require('./lib/state'); fs.writeFileSync(s.getStatePath(), 'CORRUPT', 'utf8'); const p = require('./lib/pool'); const state = s.loadState(p.DEFAULT_POOL); console.log(state.currentIndex)"` — prints "0" (recovered from corruption). Check stderr for "State corrupted, resetting".
  </verify>
  <done>lib/state.js exports loadState, saveState, getStatePath, createDefaultState. State loads and saves atomically using write-file-atomic. Missing files initialize cleanly. Corrupt files reset to defaults. Pool changes trigger index reset. All errors recover gracefully without throwing.</done>
</task>

</tasks>

<verification>
1. `npm test` or `node -e "require('./lib/pool'); require('./lib/state'); console.log('modules load')"` — all modules load without error
2. State round-trip: save state, load state, values match
3. Corruption recovery: write garbage to state.json, loadState returns defaults
4. Pool hash stability: same pool produces same hash across calls
5. Pool hash change detection: modified pool produces different hash
6. State directory auto-creation: delete ~/.config/viberipped/, saveState creates it
</verification>

<success_criteria>
- package.json exists with write-file-atomic dependency installed
- lib/pool.js exports DEFAULT_POOL (8-10 exercises) and computePoolHash (SHA256)
- lib/state.js exports loadState, saveState, getStatePath, createDefaultState
- State persists to ~/.config/viberipped/state.json with atomic writes
- Corrupt or missing state recovers to defaults without crashing
- Pool hash detects changes and triggers index reset
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-rotation-engine/01-01-SUMMARY.md`
</output>
