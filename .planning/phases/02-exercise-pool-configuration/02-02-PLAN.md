---
phase: 02-exercise-pool-configuration
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - engine.js
  - test/engine.test.js
autonomous: true

must_haves:
  truths:
    - "Engine loads configuration.json on trigger and assembles pool from equipment flags"
    - "Engine writes pool.json to ~/.config/viberipped/ with assembled exercises"
    - "Engine uses pool.json for rotation (not just in-memory assembly)"
    - "User edits to pool.json are preserved until configuration.json changes"
    - "Configuration change triggers pool.json regeneration and rotation index reset"
    - "Missing configuration.json causes engine to use bodyweight-only pool"
    - "pool.json is human-readable JSON that user can open and understand"
  artifacts:
    - path: "engine.js"
      provides: "Config-aware trigger with pool.json persistence and regeneration logic"
      exports: ["trigger"]
    - path: "test/engine.test.js"
      provides: "Integration tests for config-driven pool assembly and pool.json persistence"
  key_links:
    - from: "engine.js trigger()"
      to: "lib/config.js loadConfig()"
      via: "loads configuration.json to determine equipment"
      pattern: "loadConfig"
    - from: "engine.js trigger()"
      to: "lib/pool.js assemblePool()"
      via: "assembles pool from config equipment flags"
      pattern: "assemblePool"
    - from: "engine.js trigger()"
      to: "~/.config/viberipped/pool.json"
      via: "writes assembled pool and reads it for rotation"
      pattern: "pool\\.json"
    - from: "engine.js pool regeneration"
      to: "lib/pool.js computePoolHash()"
      via: "compares assembled pool hash to existing pool.json hash to detect config changes"
      pattern: "computePoolHash"
---

<objective>
Integrate configuration loading and pool.json persistence into the rotation engine, developed via TDD.

Purpose: Wires the config module (02-01) into the engine so that trigger() reads configuration.json, assembles the pool from equipment flags, writes pool.json for transparency, and uses pool.json for rotation. Preserves user pool.json edits until configuration changes. This completes all four Phase 2 success criteria.

Output: engine.js (modified), test/engine.test.js (extended)
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-exercise-pool-configuration/02-RESEARCH.md
@.planning/phases/02-exercise-pool-configuration/02-01-SUMMARY.md
@engine.js
@lib/config.js
@lib/pool.js
@lib/state.js
@test/engine.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for config-driven engine and pool.json persistence</name>
  <files>test/engine.test.js</files>
  <action>
Add new describe blocks to the existing test/engine.test.js file. Import loadConfig, saveConfig, getConfigPath, DEFAULT_CONFIG from lib/config.js and assemblePool, FULL_EXERCISE_DATABASE, computePoolHash from lib/pool.js.

Add these test groups:

**describe('Rotation Engine - Config-Driven Pool Assembly'):**

1. "engine uses bodyweight-only pool when no configuration.json exists" — trigger with statePath in temp dir (no config file), verify result.exercise is a bodyweight exercise (check exercise is in DEFAULT_POOL)
2. "engine includes kettlebell exercises when config enables kettlebell" — write configuration.json to temp dir with { equipment: { kettlebell: true, dumbbells: false, pullUpBar: false, parallettes: false } }, trigger enough times to see kettlebell exercises appear
3. "engine includes all equipment exercises when all enabled" — write all-true config, trigger through entire pool, verify exercises from all equipment categories appear
4. "engine falls back to bodyweight pool on invalid configuration.json" — write invalid JSON to configuration.json, trigger, verify only bodyweight exercises (same as no-config behavior)

**describe('Rotation Engine - Pool.json Persistence'):**

5. "engine creates pool.json in state directory on first trigger" — trigger once, verify pool.json file exists in temp state dir
6. "pool.json contains valid JSON array of exercises" — trigger once, read pool.json, JSON.parse, verify it's an array where every entry has name (string), reps (number), equipment (array)
7. "pool.json is human-readable (pretty-printed with 2-space indent)" — read pool.json raw content, verify it contains newlines and indentation (not single-line minified JSON)

**describe('Rotation Engine - Pool.json User Edit Preservation'):**

8. "user-edited pool.json is used for rotation when config unchanged" — trigger once (creates pool.json), manually edit pool.json to add a custom exercise, trigger again, verify custom exercise can appear in rotation
9. "configuration change triggers pool.json regeneration" — trigger with kettlebell config (creates pool.json), change config to add dumbbells, trigger again, verify pool.json now includes dumbbell exercises and custom edits from previous pool.json are gone
10. "pool.json regeneration resets rotation index to 0" — trigger several times to advance index, change config, trigger, verify rotation starts from index 0 of new pool

For these tests, the temp directory needs both a state.json path AND a configuration.json path AND a pool.json path all in the same temp directory. Add a helper or extend the trigger options to accept a configDir or similar parameter so the engine reads configuration.json and pool.json from the test directory instead of ~/.config/viberipped/.

The simplest approach: add a `configDir` option to trigger() that overrides getStateDir() for config and pool file paths. Or reuse the existing statePath's parent directory. Recommendation: use `path.dirname(statePath)` as the directory for all files (state.json, configuration.json, pool.json) — this keeps test isolation simple and matches the real layout where all three files live in ~/.config/viberipped/.

Tests MUST fail initially because engine.js does not yet load configuration.json or write pool.json.

Run: `node --test test/engine.test.js` — new tests fail, existing tests still structured correctly.
  </action>
  <verify>Run `node --test test/engine.test.js 2>&1` and confirm the NEW tests fail (the 10 new test cases). Existing tests (10 from Phase 1) should still pass or fail gracefully depending on engine changes.</verify>
  <done>test/engine.test.js has 10 new test cases in 4 new describe blocks. New tests fail because engine.js lacks config-driven pool loading and pool.json persistence.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement config-driven pool loading and pool.json persistence in engine</name>
  <files>engine.js</files>
  <action>
Modify engine.js trigger() function to:

1. **Determine file paths** — derive configDir from `path.dirname(statePath)` (whether statePath is custom or default). Set:
   - `configPath = path.join(configDir, 'configuration.json')`
   - `poolPath = path.join(configDir, 'pool.json')`

2. **Load configuration** — call `loadConfig(configPath)` from lib/config.js. This returns DEFAULT_CONFIG on any failure (fail-safe).

3. **Determine pool via regeneration check:**
   a. Assemble expected pool from config: `const assembledPool = assemblePool(config.equipment)`
   b. Compute hash of assembled pool: `const assembledHash = computePoolHash(assembledPool)`
   c. Try to load existing pool.json:
      - If pool.json exists and is valid JSON array:
        - Compute hash of existing pool.json content
        - If hashes match (config unchanged): use pool.json content as the pool (preserves user edits like added/removed exercises — but note: user edits change the hash, so the comparison is assembled-pool-hash vs assembled-pool-hash-from-last-generation, NOT vs current pool.json hash)
      - CORRECTION on hash comparison strategy: Store the hash of the ASSEMBLED pool (from config) as metadata. Compare current assembled hash to stored assembled hash. This way user edits to pool.json don't trigger regeneration — only config changes do.

   **Refined approach (simpler, matches research):**
   - Compute assembledPool from config
   - Compute assembledHash = computePoolHash(assembledPool)
   - Try to read pool.json. If it exists and is valid:
     - Read a stored `_assembledHash` field from pool.json metadata OR store the assembled hash separately
     - SIMPLEST: Store assembled hash in state.json as `configPoolHash` (alongside existing poolHash). Compare assembledHash to state.configPoolHash.
     - If match: load pool.json as-is (user edits preserved)
     - If mismatch: regenerate pool.json from assembledPool, update state.configPoolHash
   - If pool.json missing or invalid: write assembledPool to pool.json, set state.configPoolHash

   **Actually, even simpler:** Just compare the assembled pool hash to the existing pool.json hash. If they differ AND the assembled pool hash also differs from the LAST assembled pool hash (stored in state), then config changed. But this is getting complex.

   **Simplest correct approach:**
   - Keep a `configHash` in state.json = hash of the configuration.json content (or hash of assembled pool from config)
   - On each trigger: assemble pool from config, compute assembledHash
   - If state.configHash !== assembledHash: config changed, regenerate pool.json, update state.configHash
   - If state.configHash === assembledHash: config unchanged, load pool.json as-is (preserves user edits)
   - If pool.json missing/invalid: write assembledPool, set state.configHash

4. **Write pool.json** — when regenerating, use writeFileAtomic.sync with JSON.stringify(pool, null, 2) and mode 0o600. Pretty-print with 2-space indent for human readability.

5. **Use loaded pool for rotation** — pass the loaded pool (from pool.json or assembled) to the existing rotation logic. The pool passed to loadState() for hash comparison should be the ACTUAL pool being used (from pool.json), so state.poolHash tracks the real rotation pool.

6. **State schema extension** — add `configPoolHash` field to state. Update createDefaultState in lib/state.js if needed, or handle in engine.js. The configPoolHash tracks the assembled-from-config pool hash. The existing poolHash tracks the actual rotation pool hash (which may differ due to user edits to pool.json).

   Actually, to minimize changes to state.js: just handle configPoolHash in engine.js. When loading state, if configPoolHash is missing (old state from Phase 1), treat as "config never set" and trigger regeneration.

7. **Preserve backward compatibility** — if no configuration.json exists AND no pool.json exists, behavior should match Phase 1 exactly (use DEFAULT_POOL). The fail-safe chain: no config -> DEFAULT_CONFIG (all false) -> assemblePool returns bodyweight-only -> which equals DEFAULT_POOL.

8. **Import additions** — add imports for loadConfig, getConfigPath from lib/config.js and assemblePool from lib/pool.js at the top of engine.js.

9. **Keep the existing pool parameter** — trigger(pool, options) still accepts a pool parameter. When pool is explicitly provided (not default), skip config loading and pool.json logic entirely. This preserves Phase 1 test compatibility where tests pass custom pools directly. Only use config-driven logic when pool is not explicitly passed (use a sentinel or default parameter check).

   Approach: change signature to `trigger(options = {})`. If `options.pool` is provided, use it directly (Phase 1 test compat path). If not, use config-driven path. Update existing tests to pass pool via `options.pool` instead of first positional argument. OR keep backward compat by detecting: if first arg is an array, treat as pool (legacy mode). This is cleaner.

   SIMPLEST: Keep `trigger(pool = null, options = {})`. If pool is explicitly passed (not null), use legacy Phase 1 behavior. If pool is null/undefined, use config-driven behavior. Update the default from DEFAULT_POOL to null.

Run all tests: `node --test` — all tests must pass (new config-driven tests + all Phase 1 tests).
  </action>
  <verify>Run `node --test 2>&1` — all tests pass (Phase 1 rotation/cooldown/format/recovery tests + Phase 2 config/pool/engine tests). Run `node engine.js` from project root — outputs exercise JSON using bodyweight-only pool (no configuration.json exists yet). Verify ~/.config/viberipped/pool.json is created after running engine.js. Run `cat ~/.config/viberipped/pool.json` and verify it's pretty-printed JSON array of bodyweight exercises.</verify>
  <done>engine.js loads configuration.json, assembles equipment-filtered pool, writes pool.json, preserves user pool.json edits until config changes, and resets rotation on config change. All 30+ tests pass. pool.json is human-readable pretty-printed JSON. Backward compatibility with Phase 1 tests maintained.</done>
</task>

</tasks>

<verification>
1. `node --test` — all test files pass (config, pool, engine — 30+ total tests, 0 failures)
2. `node engine.js` with no configuration.json — uses bodyweight-only pool, creates pool.json
3. `cat ~/.config/viberipped/pool.json` — shows pretty-printed JSON array of 10 bodyweight exercises
4. Create config manually: `echo '{"equipment":{"kettlebell":true,"dumbbells":false,"pullUpBar":false,"parallettes":false}}' > ~/.config/viberipped/configuration.json` then `node engine.js` — pool.json regenerated with kettlebell exercises included
5. Edit pool.json manually (add custom exercise), run `node engine.js` twice — custom exercise preserved in rotation
6. Change configuration.json (add dumbbells:true), run `node engine.js` — pool.json regenerated (custom edits gone, dumbbell exercises now included)
7. Delete configuration.json, run `node engine.js` — degrades to bodyweight-only pool without crashing
</verification>

<success_criteria>
- engine.js reads configuration.json and assembles equipment-filtered pool
- pool.json written to ~/.config/viberipped/ with pretty-printed human-readable JSON
- User edits to pool.json preserved until configuration.json changes
- Configuration change triggers pool.json regeneration and rotation index reset
- Missing/invalid configuration.json degrades to bodyweight-only without crashing
- All Phase 1 tests still pass (zero regression)
- All Phase 2 tests pass (config-driven assembly, pool.json persistence, user edit preservation)
- Phase 2 success criteria 1-4 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-exercise-pool-configuration/02-02-SUMMARY.md`
</output>
