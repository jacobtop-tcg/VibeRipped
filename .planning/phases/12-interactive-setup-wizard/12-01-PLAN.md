---
phase: 12-interactive-setup-wizard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cli/ui/checkbox.js
  - lib/cli/ui/confirm.js
  - lib/cli/ui/tty.js
  - test/cli/ui.test.js
autonomous: true

must_haves:
  truths:
    - "CheckboxPrompt renders list of items with cursor highlighting and toggle state"
    - "CheckboxPrompt captures arrow keys, space, and enter via raw mode keypresses"
    - "CheckboxPrompt restores terminal state (raw mode off, cursor visible) on completion, cancel, and SIGINT"
    - "TTY guard returns false and prints helpful error with alternative commands when stdin/stdout is not a TTY"
    - "Confirm prompt accepts y/N input and returns boolean"
  artifacts:
    - path: "lib/cli/ui/checkbox.js"
      provides: "CheckboxPrompt class with render, keypress handling, and async prompt() method"
      exports: ["CheckboxPrompt"]
    - path: "lib/cli/ui/confirm.js"
      provides: "Confirm prompt utility for y/N questions"
      exports: ["confirm"]
    - path: "lib/cli/ui/tty.js"
      provides: "TTY detection guard with detailed error messaging"
      exports: ["requireTTY"]
    - path: "test/cli/ui.test.js"
      provides: "Unit tests for TTY guard and confirm prompt, spawn-based non-TTY detection test"
  key_links:
    - from: "lib/cli/ui/checkbox.js"
      to: "process.stdin"
      via: "readline.emitKeypressEvents + raw mode"
      pattern: "emitKeypressEvents.*stdin"
    - from: "lib/cli/ui/tty.js"
      to: "process.stdin.isTTY"
      via: "TTY detection check"
      pattern: "process\\.std(in|out)\\.isTTY"
---

<objective>
Build reusable interactive UI primitives: checkbox multi-select widget, confirm prompt, and TTY detection guard.

Purpose: These are the foundational building blocks for the setup wizard (Plan 02) and future interactive commands (Phase 13). Building them as standalone modules keeps Plan 02 focused on wizard logic.

Output: Three UI modules in lib/cli/ui/ plus unit tests.
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-interactive-setup-wizard/12-RESEARCH.md
@lib/cli/output.js
@bin/vibripped.js
@test/cli/config.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: TTY guard and confirm prompt utilities</name>
  <files>lib/cli/ui/tty.js, lib/cli/ui/confirm.js</files>
  <action>
Create `lib/cli/ui/` directory (new).

**lib/cli/ui/tty.js** - TTY detection guard:
- Export `requireTTY(commandName)` function
- Check both `process.stdin.isTTY` and `process.stdout.isTTY`
- If either is falsy, print to stderr:
  - `Error: {commandName} requires an interactive terminal`
  - Blank line
  - `This command cannot run in piped or non-interactive contexts.`
  - Blank line
  - `To configure non-interactively, use:`
  - `  vibripped config --kettlebell --dumbbells`
  - `  vibripped pool add "Exercise name" 15`
  - `  vibripped config set environment home`
- Set `process.exitCode = 1` and return `false`
- If both TTY, return `true`

**lib/cli/ui/confirm.js** - Y/N confirmation prompt:
- Export async `confirm(message)` function
- Uses `readline/promises` createInterface
- Displays `{message} (y/N): `
- Returns `true` if answer is 'y' or 'yes' (case-insensitive), `false` otherwise
- Always closes the readline interface in a finally block
- Default is No (capital N in prompt)
  </action>
  <verify>Run `node -e "const {requireTTY} = require('./lib/cli/ui/tty'); console.log(requireTTY('test'));"` -- should print true in terminal. Run `echo '' | node -e "..."` with piped stdin to verify false path is harder to test inline but will be tested in Task 3.</verify>
  <done>requireTTY returns boolean based on TTY state with helpful stderr output on failure. confirm() returns boolean based on y/N input.</done>
</task>

<task type="auto">
  <name>Task 2: CheckboxPrompt interactive widget</name>
  <files>lib/cli/ui/checkbox.js</files>
  <action>
Create `lib/cli/ui/checkbox.js` - CheckboxPrompt class:

**Constructor:** `new CheckboxPrompt(message, choices)`
- `message`: string displayed above choices (e.g., "Select your equipment:")
- `choices`: array of `{ label: string, value: any, checked: boolean }`
- Initialize `selectedIndex = 0`, `rendered = false`

**ANSI constants** (private, top of file):
- `CLEAR_LINE`: `\x1b[2K`
- `CURSOR_TO_START`: `\x1b[G`
- `CURSOR_UP(n)`: `\x1b[${n}A`
- `COLOR_CYAN`: `\x1b[36m`
- `COLOR_RESET`: `\x1b[0m`
- `HIDE_CURSOR`: `\x1b[?25l`
- `SHOW_CURSOR`: `\x1b[?25h`

**Checkbox characters:** Use Unicode `\u2610` (unchecked) and `\u2611` (checked).

**render() method:**
- If previously rendered, move cursor up by (choices.length + 1) lines
- Clear and write message line
- For each choice: clear line, write `{pointer} {checkbox} {label}` where:
  - pointer = `>` if selected index, ` ` otherwise
  - checkbox = checked/unchecked Unicode char
  - Highlight current line in cyan
- Set `rendered = true`

**prompt() method** (async, returns Promise):
- Call `readline.emitKeypressEvents(process.stdin)`
- Enter raw mode: `process.stdin.setRawMode(true)`
- Resume stdin: `process.stdin.resume()`
- Hide cursor: write `HIDE_CURSOR`
- Register SIGINT handler for cleanup
- Call initial `render()`
- Listen for keypress events:
  - `up` arrow: decrement selectedIndex (min 0), re-render
  - `down` arrow: increment selectedIndex (max choices.length-1), re-render
  - `space`: toggle checked on current choice, re-render
  - `return`/`enter`: cleanup, resolve with array of checked values
  - `escape`: cleanup, reject with Error('Cancelled')
  - Ctrl+C: cleanup, write newline, `process.exit(0)`
- Cleanup function (used in all exit paths):
  - `process.stdin.setRawMode(false)`
  - `process.stdin.pause()`
  - Remove keypress listeners
  - Write `SHOW_CURSOR`
  - Remove SIGINT listener

**IMPORTANT:** The cleanup function MUST be called before resolving/rejecting the promise. Raw mode left on will corrupt the terminal.

**Module export:** `module.exports = { CheckboxPrompt }`

Do NOT add 'a' key for select-all or other advanced features. Keep it minimal: arrows, space, enter, escape, Ctrl+C.
  </action>
  <verify>Manual verification only possible in TTY. Run `node -e "const {CheckboxPrompt} = require('./lib/cli/ui/checkbox'); const p = new CheckboxPrompt('Test:', [{label:'A',value:'a',checked:false},{label:'B',value:'b',checked:true}]); p.prompt().then(r => console.log('Selected:', r)).catch(e => console.log('Cancelled'));"` in a terminal to verify arrow navigation, space toggle, enter submit.</verify>
  <done>CheckboxPrompt renders interactive checkbox list, handles arrow/space/enter/escape/Ctrl+C, restores terminal state on all exit paths.</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for UI primitives</name>
  <files>test/cli/ui.test.js</files>
  <action>
Create `test/cli/ui.test.js` using existing project patterns (node:test, node:assert, child_process.spawn with isolated HOME dirs).

**TTY guard tests:**
- `requireTTY returns true when both stdin and stdout are TTY` -- cannot easily test in subprocess (stdin is pipe), but test the non-TTY path:
- `requireTTY returns false and prints error in non-TTY context` -- spawn vibripped with stdin as 'ignore', verify exit code 1 and stderr contains "requires interactive terminal" and "vibripped config" (alternative suggestion). Use a small test script that requires tty.js and calls requireTTY, or test via the setup command once it exists (defer to Plan 02 if needed).
  - Alternative: create a tiny script `node -e "const {requireTTY} = require('./lib/cli/ui/tty'); const ok = requireTTY('setup'); process.exit(ok ? 0 : 1);"` and spawn it with `stdio: ['ignore', 'pipe', 'pipe']`

**Confirm prompt tests:**
- `confirm returns true for 'y' input` -- spawn child process, write 'y\n' to stdin
- `confirm returns true for 'yes' input` -- spawn child process, write 'yes\n' to stdin
- `confirm returns false for 'n' input` -- spawn child process, write 'n\n' to stdin
- `confirm returns false for empty input` -- spawn child process, write '\n' to stdin (default No)
- For each: create a small test helper script or use `-e` flag that requires confirm.js, calls confirm(), and prints the result

**CheckboxPrompt tests:**
- `CheckboxPrompt module loads without error` -- require and verify constructor exists
- Skip full interactive testing (requires PTY) per research recommendation. The checkpoint in Plan 02 covers manual interactive verification.

Use the same isolated temp HOME pattern from `test/cli/config.test.js`: `os.tmpdir() + unique suffix`, cleanup in close handler.

All tests must pass with `node --test test/cli/ui.test.js`.
  </action>
  <verify>`node --test test/cli/ui.test.js` passes all tests. `node --test` (full suite) still passes.</verify>
  <done>TTY guard tested for non-TTY rejection with helpful error. Confirm prompt tested for y/yes/n/empty inputs. CheckboxPrompt module loads cleanly. Full test suite passes.</done>
</task>

</tasks>

<verification>
- `node --test test/cli/ui.test.js` -- all UI primitive tests pass
- `node --test` -- full test suite still passes (no regressions)
- `node -e "require('./lib/cli/ui/checkbox')"` -- module loads without error
- `node -e "require('./lib/cli/ui/tty')"` -- module loads without error
- `node -e "require('./lib/cli/ui/confirm')"` -- module loads without error
</verification>

<success_criteria>
- Three UI modules exist in lib/cli/ui/ (checkbox.js, confirm.js, tty.js)
- CheckboxPrompt renders interactive multi-select with arrow/space/enter navigation
- TTY guard detects non-interactive context and prints helpful alternative commands
- Confirm prompt handles y/N input with sensible default (No)
- Terminal state always restored (raw mode off, cursor visible) on all exit paths
- All tests pass including full suite regression check
</success_criteria>

<output>
After completion, create `.planning/phases/12-interactive-setup-wizard/12-01-SUMMARY.md`
</output>
