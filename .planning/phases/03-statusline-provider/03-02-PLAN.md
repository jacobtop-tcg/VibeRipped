---
phase: 03-statusline-provider
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - statusline.js
  - test/statusline.test.js
autonomous: false

must_haves:
  truths:
    - "statusline.js reads stdin JSON, detects processing, triggers engine, formats output to stdout"
    - "No output when Claude Code is not processing (silent operation)"
    - "No output when engine returns cooldown (disappears completely)"
    - "Exercise prompt appears with ANSI color when processing detected"
    - "Script exits cleanly with code 0 on all paths (success, no-processing, cooldown, error)"
  artifacts:
    - path: "statusline.js"
      provides: "Claude Code statusline provider entry point"
      min_lines: 30
    - path: "test/statusline.test.js"
      provides: "Integration tests for statusline entry point"
      contains: "statusline.js"
  key_links:
    - from: "statusline.js"
      to: "lib/statusline/stdin.js"
      via: "require and parseStdin call"
      pattern: "require.*statusline/stdin"
    - from: "statusline.js"
      to: "lib/statusline/detection.js"
      via: "require and isProcessing call"
      pattern: "require.*statusline/detection"
    - from: "statusline.js"
      to: "engine.js"
      via: "require and trigger(null) call"
      pattern: "trigger\\(null\\)"
    - from: "statusline.js"
      to: "lib/statusline/format.js"
      via: "require and formatExercise call"
      pattern: "require.*statusline/format"
    - from: "statusline.js"
      to: "process.stdout"
      via: "process.stdout.write for formatted output"
      pattern: "process\\.stdout\\.write"
---

<objective>
Create the statusline.js entry point that wires stdin parsing, process detection, engine trigger, and ANSI formatting into a complete Claude Code statusline provider script.

Purpose: This is the integration layer that makes VibeRipped usable as a real Claude Code statusline provider. All core logic exists in modules from Plan 01 and Phases 1-2. This plan wires them together and validates with a real Claude Code session.

Output: Working statusline.js that can be registered in Claude Code settings as a statusline provider.
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-statusline-provider/03-RESEARCH.md
@.planning/phases/03-statusline-provider/03-01-SUMMARY.md
@engine.js
@lib/statusline/stdin.js
@lib/statusline/detection.js
@lib/statusline/format.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create statusline.js entry point with integration tests</name>
  <files>statusline.js, test/statusline.test.js</files>
  <action>
**Create statusline.js** at project root (same level as engine.js). This is the script Claude Code will invoke as a statusline provider.

Implementation flow:
```
1. Buffer all stdin data chunks into a string
2. On stdin 'end': parse JSON via parseStdin()
3. If parse fails: exit 0 silently (no output = statusline shows nothing)
4. Check isProcessing(data): if false, exit 0 silently
5. Call trigger(null) from engine.js (config-driven mode)
6. If result.type === 'cooldown': exit 0 silently (disappear during cooldown per STAT-03)
7. If result.type === 'exercise': write formatExercise(result.exercise.name, result.exercise.reps) to stdout
8. Exit 0
```

Critical implementation details:
- Use `process.stdout.write()` (NOT console.log) to avoid trailing newline that could affect statusline rendering. Actually, based on research, console.log is fine as each call creates a statusline row. Use `process.stdout.write(formatted)` to be safe -- one clean output line.
- ALL diagnostic/error output to stderr (console.error), NEVER stdout. stdout is exclusively for statusline content.
- Wrap entire flow in try/catch at top level. On any uncaught error: console.error the message, exit 0 (never crash the statusline with non-zero exit).
- Do NOT set process.stdin.resume() -- data events fire automatically when piped.
- Set `process.stdin.setEncoding('utf8')` before attaching data listener.

The shebang line should be `#!/usr/bin/env node` for direct execution.

**Add integration tests to test/statusline.test.js** (append to existing unit tests from Plan 01):

New describe block "statusline.js integration":
1. Test: pipe valid processing JSON to statusline.js via child_process.execSync, verify stdout contains ANSI-formatted exercise
2. Test: pipe non-processing JSON (current_usage: null) to statusline.js, verify stdout is empty
3. Test: pipe invalid JSON to statusline.js, verify stdout is empty and exit code is 0
4. Test: pipe empty stdin to statusline.js, verify stdout is empty and exit code is 0

For integration tests, use child_process.execSync or child_process.spawnSync to run `node statusline.js` with input piped via stdin. Example:
```javascript
const { execSync } = require('child_process');
const input = JSON.stringify({ context_window: { current_usage: { input_tokens: 500, cache_read_input_tokens: 0 } } });
const result = execSync(`echo '${input}' | node statusline.js`, { encoding: 'utf8', env: { ...process.env, HOME: tmpDir } });
```

IMPORTANT: Integration tests need isolated state directories. Set HOME or XDG_CONFIG_HOME env var to a temp directory so engine.js writes to isolated state, not the user's real ~/.config/viberipped/.

The integration tests will also need `bypassCooldown` behavior. Since statusline.js calls trigger(null) without bypassCooldown, rapid test runs may hit cooldown. Two options:
- Option A: Set env var VIBERIPPED_BYPASS_COOLDOWN=1 that statusline.js reads and passes to trigger options (preferred -- useful for testing)
- Option B: Use spawnSync with timeout and accept that only the first test triggers exercise

Use Option A: Add env var check in statusline.js: `const bypassCooldown = process.env.VIBERIPPED_BYPASS_COOLDOWN === '1';` and pass to trigger options. This is useful for future testing too.
  </action>
  <verify>
1. Run `node --test test/statusline.test.js` -- all tests pass (unit + integration)
2. Run `node --test` -- all tests pass (zero regression, 43+ existing + new)
3. Run `echo '{"context_window":{"current_usage":{"input_tokens":500,"cache_read_input_tokens":0}}}' | node statusline.js` -- stdout shows ANSI-colored exercise prompt
4. Run `echo '{"context_window":{"current_usage":null}}' | node statusline.js` -- stdout is empty
5. Run `echo 'invalid json' | node statusline.js; echo $?` -- exit code 0, no stdout
  </verify>
  <done>statusline.js exists at project root, reads stdin JSON, detects processing, triggers engine, outputs ANSI-formatted exercise. All integration tests pass. Silent on non-processing, cooldown, and errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify statusline provider with real Claude Code session</name>
  <files>statusline.js</files>
  <action>
Human verification checkpoint. Claude has built the complete statusline provider. The user must now test it with a real Claude Code session to validate the process detection heuristic (MEDIUM confidence from research).

Register VibeRipped as a Claude Code statusline provider by adding to Claude Code settings:
```json
{
  "statusline": {
    "providers": [
      {
        "name": "viberipped",
        "command": "node /Users/jacob/Documents/apps/VibeRipped/statusline.js"
      }
    ]
  }
}
```

Then send a non-trivial prompt and observe the statusline for a cyan bold exercise prompt.
  </action>
  <verify>
1. During/after Claude Code processing: cyan bold exercise prompt appears in statusline (e.g., "Pushups x15")
2. When Claude Code is idle: no exercise prompt visible (silent operation)
3. No notifications, sounds, or popups outside the statusline
4. After 5-minute cooldown, next prompt shows a different exercise (rotation advances)
5. If exercise does NOT appear, run manually to isolate issue:
   `echo '{"context_window":{"current_usage":{"input_tokens":500,"cache_read_input_tokens":0}}}' | node /Users/jacob/Documents/apps/VibeRipped/statusline.js`
  </verify>
  <done>User confirms exercise prompts appear during active Claude Code processing and disappear when idle. Detection heuristic validated or tuning needs identified.</done>
</task>

</tasks>

<verification>
1. `node --test` -- all tests pass (unit + integration + existing = 43+ tests)
2. `echo '{"context_window":{"current_usage":{"input_tokens":500,"cache_read_input_tokens":0}}}' | node statusline.js` -- outputs ANSI exercise
3. `echo '{"context_window":{"current_usage":null}}' | node statusline.js` -- empty output
4. `echo '' | node statusline.js; echo $?` -- exit 0, empty output
5. `file statusline.js` -- exists at project root
6. Real Claude Code session shows exercise prompt during processing (checkpoint)
</verification>

<success_criteria>
- statusline.js wires all modules: stdin -> detection -> engine -> format -> stdout
- Silent operation: no output when not processing, on cooldown, or on error
- ANSI cyan bold exercise appears when processing detected
- Exit code 0 on all paths
- Real Claude Code session validates the detection heuristic works (checkpoint)
- Zero regression on all existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-statusline-provider/03-02-SUMMARY.md`
</output>
