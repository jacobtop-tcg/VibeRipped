---
phase: 08-data-model-extensions
plan: 02
type: tdd
wave: 2
depends_on: ["08-01"]
files_modified:
  - lib/migration.js
  - engine.js
  - test/migration.test.js
  - test/engine.test.js
autonomous: true

must_haves:
  truths:
    - "v1.0 config files are automatically backed up on first v1.1 launch"
    - "v1.0 config files are migrated to v1.1 schema with correct defaults"
    - "Migration is idempotent (running twice does not create duplicate backups or corrupt data)"
    - "Already-migrated v1.1 files are not re-migrated"
    - "Engine trigger() integrates migration seamlessly without changing output format"
    - "Backup files are created alongside originals with .v1.0.backup suffix"
  artifacts:
    - path: "lib/migration.js"
      provides: "Schema migration logic with backup creation"
      exports: ["migrateConfigIfNeeded", "migrateStateIfNeeded", "migratePoolIfNeeded"]
    - path: "engine.js"
      provides: "Migration integration in trigger flow"
      contains: "migrateConfigIfNeeded"
    - path: "test/migration.test.js"
      provides: "Migration unit tests covering backup, idempotency, and v1.0-to-v1.1 upgrade"
      contains: "migrateConfigIfNeeded"
  key_links:
    - from: "engine.js"
      to: "lib/migration.js"
      via: "require and call in trigger()"
      pattern: "require.*migration"
    - from: "lib/migration.js"
      to: "lib/config.js"
      via: "uses loadConfig for validation after migration"
      pattern: "loadConfig"
    - from: "lib/migration.js"
      to: "lib/pool.js"
      via: "uses validateExercise for pool migration validation"
      pattern: "validateExercise"
---

<objective>
Create migration module that automatically upgrades v1.0 config/pool/state files to v1.1 schema on first launch, with backup creation for rollback safety. Integrate migration into the engine trigger flow.

Purpose: Ensure seamless upgrade path from v1.0 to v1.1 so existing users never encounter errors or data loss when updating VibeRipped.
Output: lib/migration.js module with tested backup and migration logic, engine.js integration point.
</objective>

<execution_context>
@/Users/jacob/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jacob/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-data-model-extensions/08-RESEARCH.md
@.planning/phases/08-data-model-extensions/08-01-SUMMARY.md
@engine.js
@lib/config.js
@lib/pool.js
@lib/state.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/migration.js with backup and schema migration logic</name>
  <files>lib/migration.js, test/migration.test.js</files>
  <action>
TDD: Write tests first, then implement.

**Tests to create in test/migration.test.js:**

Setup: Each test uses an isolated temp directory (same pattern as existing tests: `os.tmpdir() + unique suffix`). Write v1.0-format files to temp dir, run migration, assert results.

Config migration tests:
- migrateConfigIfNeeded on v1.0 config (no schemaVersion) creates .v1.0.backup file
- migrateConfigIfNeeded on v1.0 config adds environment: "anywhere" and schemaVersion: "1.1"
- migrateConfigIfNeeded on v1.0 config preserves existing equipment and difficulty fields
- migrateConfigIfNeeded on v1.1 config (schemaVersion: "1.1") does NOT create backup
- migrateConfigIfNeeded on v1.1 config returns config unchanged
- migrateConfigIfNeeded called twice only creates one backup (idempotent)
- migrateConfigIfNeeded on missing config file returns null (no crash)

Pool migration tests:
- migratePoolIfNeeded on v1.0 pool (exercises without category/type) creates .v1.0.backup
- migratePoolIfNeeded adds type: "reps" and environments: ["anywhere"] to exercises missing them
- migratePoolIfNeeded does NOT add category to exercises (category=null is valid default, user/Phase 11 assigns categories)
- migratePoolIfNeeded on v1.1 pool (exercises already have type field) does NOT create backup
- migratePoolIfNeeded preserves user-added custom exercises (name/reps intact)
- migratePoolIfNeeded on missing pool file returns null

State migration tests:
- migrateStateIfNeeded on v1.0 state (no recentCategories) creates .v1.0.backup
- migrateStateIfNeeded adds recentCategories: [] and schemaVersion: "1.1"
- migrateStateIfNeeded preserves currentIndex, lastTriggerTime, poolHash, totalTriggered
- migrateStateIfNeeded on v1.1 state does NOT create backup
- migrateStateIfNeeded on missing state file returns null

**Implementation in lib/migration.js:**

```javascript
const fs = require('fs');
const path = require('path');
const writeFileAtomic = require('write-file-atomic');
```

**migrateConfigIfNeeded(configPath):**
1. Try to read configPath. If ENOENT, return null.
2. Parse JSON. If invalid, return null (let loadConfig handle recovery).
3. Check `config.schemaVersion === "1.1"` - if so, return config (already migrated).
4. Create backup: `${configPath}.v1.0.backup` using `fs.copyFileSync` (only if backup doesn't exist).
5. Add defaults: `environment: config.environment || "anywhere"`, `schemaVersion: "1.1"`.
6. Write migrated config using `writeFileAtomic.sync`.
7. Log migration to stderr: `console.error('Migrated configuration.json to v1.1 schema')`.
8. Return migrated config.

**migratePoolIfNeeded(poolPath):**
1. Try to read poolPath. If ENOENT, return null.
2. Parse JSON. If invalid or not array, return null.
3. Check if first exercise has `type` field - if so, assume already migrated, return pool.
4. Create backup: `${poolPath}.v1.0.backup` (only if backup doesn't exist).
5. For each exercise: add `type: "reps"` if missing, add `environments: ["anywhere"]` if missing. Do NOT add category (leave it undefined - category assignment is a Phase 11 concern for user pools).
6. Write migrated pool using `writeFileAtomic.sync`.
7. Return migrated pool.

**migrateStateIfNeeded(statePath):**
1. Try to read statePath. If ENOENT, return null.
2. Parse JSON. If invalid, return null.
3. Check `state.schemaVersion === "1.1"` - if so, return state (already migrated).
4. Create backup: `${statePath}.v1.0.backup` (only if backup doesn't exist).
5. Add defaults: `recentCategories: state.recentCategories || []`, `schemaVersion: "1.1"`.
6. Write migrated state using `writeFileAtomic.sync`.
7. Return migrated state.

**createBackup(filePath)** (internal helper):
1. `const backupPath = filePath + '.v1.0.backup'`
2. `if (!fs.existsSync(backupPath)) fs.copyFileSync(filePath, backupPath)`
3. Return backupPath

Export: `{ migrateConfigIfNeeded, migratePoolIfNeeded, migrateStateIfNeeded }`

**Important patterns:**
- All functions are synchronous (matching existing codebase pattern)
- All functions return null on missing/corrupt files (caller decides recovery)
- Backup uses fs.copyFileSync (preserves exact original content)
- Migration uses writeFileAtomic.sync (crash-safe writes, matching existing pattern)
- Idempotency: check schemaVersion/type before migrating, check backup existence before creating
  </action>
  <verify>Run `node --test test/migration.test.js` - all migration tests pass.</verify>
  <done>lib/migration.js exports three migration functions. Each creates .v1.0.backup before modifying files. Migration is idempotent. Missing files return null without crashing. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate migration into engine.js trigger flow</name>
  <files>engine.js, test/engine.test.js</files>
  <action>
**Tests to add in test/engine.test.js** (new describe block "v1.1 migration integration"):
- trigger() with v1.0 config file creates configuration.json.v1.0.backup in state directory
- trigger() with v1.0 state file creates state.json.v1.0.backup in state directory
- trigger() with v1.0 pool file creates pool.json.v1.0.backup in state directory
- trigger() still returns valid exercise response after migration (type: 'exercise', has prompt)
- trigger() with already-migrated v1.1 files does NOT create new backups
- trigger() called twice only produces one set of backups (idempotent end-to-end)

Setup: Use isolated temp dir with v1.0-format files (same pattern as existing engine tests with options.statePath override).

**Implementation in engine.js:**

1. Add require at top: `const { migrateConfigIfNeeded, migratePoolIfNeeded, migrateStateIfNeeded } = require('./lib/migration');`

2. In the config-driven mode block (after `const configPath` and `const poolPath` are set, before `const config = loadConfig(configPath)`), add migration calls:
   ```
   // Migrate v1.0 files to v1.1 schema on first launch
   migrateConfigIfNeeded(configPath);
   migratePoolIfNeeded(poolPath);
   migrateStateIfNeeded(statePath);
   ```

3. Migration runs BEFORE loadConfig/loadState, so those functions read already-migrated files. Return values from migration functions are intentionally ignored â€” loadConfig/loadState handle the actual data loading with their own validation and defaults.

4. Migration only runs in config-driven mode (pool === null), not in legacy mode with explicit pool. This is correct because legacy mode is for tests that provide their own pool.

**Important:** The migration calls are fire-and-forget at the engine level. If migration fails (file missing, corrupt, etc.), the existing loadConfig/loadState recovery paths handle it gracefully. This keeps the migration integration minimal and non-breaking.
  </action>
  <verify>Run `node --test test/engine.test.js` - all existing and new tests pass. Then run `node --test` for full suite verification. Finally, `node engine.js` should still produce valid JSON output.</verify>
  <done>engine.js calls migration functions before loading config/pool/state in config-driven mode. v1.0 users get automatic backup + migration on first v1.1 launch. All existing engine behavior preserved. Full test suite green.</done>
</task>

</tasks>

<verification>
1. `node --test` - full test suite passes (zero regressions)
2. Create temp v1.0 config, run engine, verify .v1.0.backup files created
3. Run engine again, verify no duplicate backups
4. `node engine.js` produces valid exercise JSON (migration transparent to output)
5. Check backup content matches original v1.0 file exactly
</verification>

<success_criteria>
- lib/migration.js exists with three exported migration functions
- Each migration function creates .v1.0.backup before modifying files
- Migration is idempotent (safe to run multiple times)
- Already-v1.1 files are not re-migrated
- Missing files return null without crashing
- engine.js integrates migration in config-driven mode trigger flow
- All existing tests pass (zero regressions)
- New migration and integration tests pass
- `node engine.js` still produces valid output after changes
</success_criteria>

<output>
After completion, create `.planning/phases/08-data-model-extensions/08-02-SUMMARY.md`
</output>
